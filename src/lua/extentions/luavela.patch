diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 96a9ff1..8fe2dcd 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -52,6 +52,7 @@ make_source_list(SOURCES_RUNTIME # Core runtime
     uj_hotcnt.c
     uj_coverage.c
     lib/init.c
+    uj_mapi.c
 )
 
 make_source_list(SOURCES_FRONTEND # Lua frontend
@@ -501,6 +502,7 @@ install (FILES
     lauxlib.h   # Auxiliary library's C API
     lextlib.h   # uJIT-specific extensions of the C API
     lua.hpp     # Convenience wrapper for C++
+    lmisclib.h  # Tarantool-specific extensions of the C API
   DESTINATION include/ujit
     PERMISSIONS
       OWNER_READ OWNER_WRITE
diff --git a/src/lj_tab.c b/src/lj_tab.c
index 93b59b0..b8547b6 100644
--- a/src/lj_tab.c
+++ b/src/lj_tab.c
@@ -593,7 +593,8 @@ TValue* lj_tab_newkey(lua_State *L, GCtab *t, const TValue *key) {
       n = freenode;
     }
   }
-  copyTV(L, &n->key, key);
+  /* NB: not use copyTV here -- key may be already dead (e.g. at rehashing). */
+  n->key = *key;
   if (LJ_UNLIKELY(tvismzero(&n->key))) { setrawV(&n->key, 0); }
   lj_gc_anybarriert(L, t);
   lua_assert(tvisnil(&n->val));
diff --git a/src/uj_vmstate.h b/src/uj_vmstate.h
index 7bdcd2c..eadb5ae 100644
--- a/src/uj_vmstate.h
+++ b/src/uj_vmstate.h
@@ -86,7 +86,7 @@ struct vmstate_context {
 /* Retrieve current VM state. */
 static LJ_AINLINE enum vmstate uj_vmstate_get(const volatile vmstate_t *st)
 {
-	return ~(*st);
+	return (enum vmstate)~(*st);
 }
 
 /* Set VM state to vmst. */
diff --git a/src/utils/strscan.c b/src/utils/strscan.c
index 38d0680..0a46e1d 100644
--- a/src/utils/strscan.c
+++ b/src/utils/strscan.c
@@ -325,6 +325,49 @@ static StrScanFmt strscan_dec(const uint8_t *p, FpConv *o,
   return fmt;
 }
 
+/* Parse binary number. */
+static StrScanFmt strscan_bin(const uint8_t *p, FpConv *o,
+			      StrScanFmt fmt, uint32_t opt,
+			      int32_t ex2, int32_t neg, uint32_t dig)
+{
+  uint64_t x = 0;
+  uint32_t i;
+
+  if (ex2 || dig > 64) return STRSCAN_ERROR;
+
+  /* Scan binary digits. */
+  for (i = dig; i; i--, p++) {
+    if ((*p & ~1) != '0') return STRSCAN_ERROR;
+    x = (x << 1) | (*p & 1);
+  }
+
+  /* Format-specific handling. */
+  switch (fmt) {
+  case STRSCAN_INT:
+    if (!(opt & STRSCAN_OPT_TONUM) && x < 0x80000000u+neg) {
+      o->i = neg ? -(int32_t)x : (int32_t)x;
+      return STRSCAN_INT;  /* Fast path for 32 bit integers. */
+    }
+    if (!(opt & STRSCAN_OPT_C)) { fmt = STRSCAN_NUM; break; }
+    /* fallthrough */
+  case STRSCAN_U32:
+    if (dig > 32) return STRSCAN_ERROR;
+    o->i = neg ? -(int32_t)x : (int32_t)x;
+    return STRSCAN_U32;
+  case STRSCAN_I64:
+  case STRSCAN_U64:
+    o->u = neg ? (uint64_t)-(int64_t)x : x;
+    return fmt;
+  default:
+    break;
+  }
+
+  /* Reduce range, then convert to double. */
+  if ((x & U64x(c0000000,0000000))) { x = (x >> 2) | (x & 3); ex2 += 2; }
+  strscan_double(x, o, ex2, neg);
+  return fmt;
+}
+
 /* Scan string containing a number. Returns format. Returns value in d. */
 StrScanFmt strscan_tonumber(const uint8_t *p, double *d, uint32_t opt) {
   int32_t neg = 0;
@@ -363,8 +406,11 @@ StrScanFmt strscan_tonumber(const uint8_t *p, double *d, uint32_t opt) {
 
     /* Determine base and skip leading zeros. */
     if (LJ_UNLIKELY(*p <= '0')) {
-      if (*p == '0' && lj_char_casecmp(p[1], 'x')) {
-        base = 16, cmask = LJ_CHAR_XDIGIT, p += 2;
+      if (*p == '0') {
+	if (lj_char_casecmp(p[1], 'x'))
+	  base = 16, cmask = LJ_CHAR_XDIGIT, p += 2;
+	else if (lj_char_casecmp(p[1], 'b'))
+	  base = 2, cmask = LJ_CHAR_DIGIT, p += 2;
       }
       for ( ; ; p++) {
         if (*p == '0') {
@@ -403,7 +449,7 @@ StrScanFmt strscan_tonumber(const uint8_t *p, double *d, uint32_t opt) {
     }
 
     /* Parse exponent. */
-    if (lj_char_casecmp(*p, (uint32_t)(base == 16 ? 'p' : 'e'))) {
+    if (base >= 10 && lj_char_casecmp(*p, (uint32_t)(base == 16 ? 'p' : 'e'))) {
       uint32_t xx;
       int negx = 0;
       fmt = STRSCAN_NUM; p++;
@@ -464,7 +510,11 @@ StrScanFmt strscan_tonumber(const uint8_t *p, double *d, uint32_t opt) {
 
     if (base == 16) {
       fmt = strscan_hex(sp, o, fmt, opt, ex, neg, dig);
-    } else {
+    }
+    else if (base == 2) {
+      fmt = strscan_bin(sp, o, fmt, opt, ex, neg, dig);
+    }
+    else {
       fmt = strscan_dec(sp, o, fmt, opt, ex, neg, dig);
     }
 
